仔细分析后，可以发现程序有以下几个问题

在添加 note 时，程序会记录 note 对应的大小，该大小会用于控制读取 note 的内容，但是读取的循环变量 i 是无符号变量，执行size-1>i时，如果size=0，则会永远成立。所以比较时都会转换为无符号变量，那么当我们输入 size 为 0 时，glibc 根据其规定，会分配 0x20 个字节，但是程序读取的内容却并不受到限制，故而会产生堆溢出。
程序在每次编辑 note 时，都会申请 0xa0 大小的内存，但是在 free 之后并没有设置为 NULL。
在上述程序中有一个全局变量ptr，用来记录每次分配的内存地址，在.bss段中，地址为0x0000000000602120。
其中这三个 chunk 申请时的大小分别为 0x80，0，0x80，chunk1 虽然申请的大小为 0，但是 glibc 的要求 chunk 块至少可以存储 4 个必要的字段 (prev_size,size,fd,bk)，所以会分配 0x20 的空间。同时，由于无符号整数的比较问题，可以为该 note 输入任意长的字符串。

这里需要注意的是，chunk0 中一共构造了两个 chunk

chunk ptr[0]，这个是为了 unlink 时修改对应的值。
chunk ptr[0]'s nextchunk，这个是为了使得 unlink 时的第一个检查满足。
利用代码：

 利用代码
代码中首先分配了三个note，当构造完三个 note 后，堆的基本构造如图 1 所示。


                                   +-----------------+ high addr
                                   |      ...        |
                                   +-----------------+
                                   |      'b'*8      |
                ptr[2]-----------> +-----------------+
                                   |    size=0x91    |
                                   +-----------------+
                                   |    prevsize     |
                                   +-----------------|------------
                                   |    unused       |
                                   +-----------------+
                                   |    'a'*8        |
                 ptr[1]----------> +-----------------+  chunk 1
                                   |    size=0x20    |
                                   +-----------------+
                                   |    prevsize     |
                                   +-----------------|-------------
                                   |    unused       |
                                   +-----------------+
                                   |  prev_size=0x60 |
           ptr[0]'s nextchunk----->+-----------------+
                                   |    64*'a'       |
                                   +-----------------+
                                   |    fakebk       |
                                   +-----------------+
                                   |    fakefd       |
                                   +-----------------+
                                   |    0x61         |  chunk 0
                                   +-----------------+
                                   |    'a *8        |
                 ptr[0]----------> +-----------------+
                                   |    size=0x91    |
                                   +-----------------+
                                   |    prev_size    |
                                   +-----------------+  low addr
                                           图1
释放 chunk1 - 覆盖 chunk2 - 释放 chunk2
对应的代码如下
deletenote(1)
content = 'a' * 16 + p64(0xa0) + p64(0x90)
newnote(0, content)
deletenote(2)
首先释放 chunk1，由于该 chunk 属于 fastbin，所以下次在申请的时候仍然会申请到该 chunk，同时由于上面所说的类型问题，我们可以读取任意字符，所以就可以覆盖 chunk2，覆盖之后如图 2 所示。

                                   +-----------------+high addr
                                   |      ...        |
                                   +-----------------+
                                   |   '\x00'+'b'*7  |
                ptr[2]-----------> +-----------------+ chunk 2
                coverValue1        |    size=0x90    |
                                   +-----------------+
                coverValue2        |    0xa0         |
                                   +-----------------|------------
                                   |    'a'*8        |
                                   +-----------------+
                                   |    'a'*8        |
                 ptr[1]----------> +-----------------+ chunk 1
                                   |    size=0x20    |
                                   +-----------------+
                                   |    prevsize     |
                                   +-----------------|-------------
                                   |    unused       |
                                   +-----------------+
                                   |  prev_size=0x60 |
             ptr[0]'s nextchunk--->+-----------------+
                                   |    64*'a'       |
                                   +-----------------+
                                   |    fakebk       |
                                   +-----------------+
                                   |    fakefd       |
               fake chunk--->      +-----------------+
                                   |    0x61         |  chunk 0
                                   +-----------------+
                                   |    'a *8        |
                 ptr[0]----------> +-----------------+
                                   |    size=0x91    |
                                   +-----------------+
                                   |    prev_size    |
                                   +-----------------+  low addr
                                           图2



和图1相比，经历了chuck1的分配和释放，造成了两个值的变更，就是图2中的coverValue1和coverValue12，coverValue1导致chunk2的前一个虚拟地址空间连续块由以及分配变为空闲，所以在释放chunk2的时候，会造成合并。
而合并操作进行时，会根据coverValue2来确定前一个块的大小，coverValue2使前一个块变为伪造的chunk，就是图2中fake chunk处，fakefd和fakebk则是伪造的，必须保证unlink的检测条件，fakefd = ptr - 0x18，fakebk = ptr - 0x10
图2中的fake ptr[0] chunk's nextchunk是根据fake chunk的size来确定的，也就是0x60，第二个条件要绕过去就需要构造第二个chunk，在fake chunk位置0x60之后的位置放置一个pre_size为0x60的chunk
在unlink之后，ptr被修改为ptr-0x18，注意，ptr的值就是在查看源码时发现的，存放第一个note的位置，在向note写入3个字节后，ptr的值又会被覆盖一次，所以可以使用一个像note的写入操作达到控制ptr为任意值。然后利用note的写操作更改GOT
在选择覆盖函数的GOT时，选择atoi，因为在switch语句之前会读入一个选择，用到atoi函数，并且程序没有用到system函数，所以必须计算两个函数的偏移才能得出system的libc库位置，最后覆盖也选用这个函数
